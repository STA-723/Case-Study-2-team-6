---
title: "BK Workspace"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(dplyr)
require(corrgram)
require(corrplot)
require(lubridate)
require(quanteda)
require(stringr)
```

Normalized Reviews per Month

I figured that reviews_per_month was a better metric than total reviews to measure popularity, but saw that reviews_per_month penalized listings that have been inactive for long periods of time. Run this chunk to see how "normalized average reviews" adjusts for that. Woot woot :)
```{r}
data <- read_csv("AB_NYC_2019.csv")

data <- data %>% 
  mutate(last_review = ymd(last_review)) %>% 
  mutate(months_inactive = round(as.numeric(ymd("2019-07-08") - last_review)/30.42)) %>% 
  mutate(months_active = (number_of_reviews - reviews_per_month*months_inactive)/reviews_per_month) %>% 
  mutate(nrml_avg_reviews = case_when(
    reviews_per_month>0 ~ number_of_reviews/months_active,
    is.na(reviews_per_month) ~ 0))
  

data %>% 
  select(last_review, reviews_per_month, nrml_avg_reviews)
```



TEXT ANALYSIS SCRATCH WORK
```{r}
#Length of name (in characters)
# str_length(data$name)
# str_detect(data$name, "[*!]")
# str_detect(data$name, "^[:upper:]+$")


#str_count(data$name, "[:upper:]")/str_length(data$name)

corpus_data <- corpus(data$name)
tokens_data <- tokens(corpus_data, remove_punct = TRUE)
tokens_data_pad <- tokens_remove(tokens_data, pattern = stopwords('en'))
head(tokens_data_pad)

tokens_dfm<- dfm(tokens_data_pad)
topfeatures(tokens_dfm, 20)
textstat_frequency(tokens_dfm)
```




EDA SCRATCH WORK
```{r}
data <- read_csv("AB_NYC_2019.csv")
apply(data, 2, FUN = function(x){sum(is.na(x))}) #last review and reviews per month have tons of missing values. Last review would not be useful in any case, reviews per month is maybe slightly better than number of reviews, but not worth the missingness. POSSIBLE. Impute reviews per month as 0 for NA. Retains data. Probably exclude longitude and latitude, would be difficult to interpret, would need to stay continuous. Info is captured by neighborhood group. 

#Are we trying to estimate two response variables? Popularity and price? Or is one a function of the other? Price may be a quadratic term influencing popularity.
hist(data$price)
summary(data$price)
data %>% 
  arrange(desc(price)) %>% 
  select(price) #Probably should not exclude any very pricey ones, there are a good number of them

data2 <- data %>% 
  filter(is.na(reviews_per_month)) %>% 
  select(c(neighbourhood_group, neighbourhood, price, minimum_nights, number_of_reviews, calculated_host_listings_count, availability_365))
View(data2)

summary(data$reviews_per_month)
summary(data$number_of_reviews)

data3 <- data %>% 
  arrange(neighbourhood_group, neighbourhood) %>% 
  filter(neighbourhood == "Riverdale")
View(data3)

data %>% 
  group_by(neighbourhood_group) %>% 
  summarise(avg_price = mean(price))

data %>% 
  group_by(neighbourhood_group, neighbourhood) %>% 
  summarise(avg_price = mean(price))

data %>% 
  filter(!is.na(reviews_per_month)) %>% 
  group_by(neighbourhood_group, neighbourhood) %>% 
  summarise(avg_reviews_per_month = mean(reviews_per_month))

data %>% 
  group_by(neighbourhood_group, neighbourhood) %>% 
  count() %>% 
  arrange (n)

data %>% 
  arrange(desc(price)) %>% 
  slice(1:2445) %>% 
  select(price)

.05*dim(data)[1]
summary(data$price) #how to construct a prior covariance that captures 95% of data when it is so skewed?

data4 <- data %>% 
  filter(!is.na(reviews_per_month))
summary(data4$price)

data %>% 
  filter(number_of_reviews == 0) %>% 
  count()

data %>% 
  filter(is.na(name))

corrplot(data4)

data %>% 
  arrange(desc(minimum_nights)) %>% 
  select(minimum_nights)

data %>% 
  filter(minimum_nights == 180) %>% 
  select(price)

data %>% 
  arrange(desc(last_review)) %>% 
  select(last_review)  #Last Review collected on 2019-07-08

data <- data %>% 
  mutate(last_review = ymd(last_review)) %>% 
  mutate(months_inactive = round(as.numeric(ymd("2019-07-08") - last_review)/30.42)) %>% 
  mutate(months_active = (number_of_reviews - reviews_per_month*months_inactive)/reviews_per_month) %>% 
  mutate(nrml_avg_reviews = number_of_reviews/months_active) %>% 
  select(number_of_reviews, reviews_per_month, last_review, months_inactive, months_active, nrml_avg_reviews)

data %>% 
  filter(name %in% "room")


```

